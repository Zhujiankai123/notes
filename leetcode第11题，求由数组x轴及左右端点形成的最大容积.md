给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。  
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
  
说明：你不能倾斜容器。

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)  
输入：[1,8,6,2,5,4,8,3,7]  
输出：49   
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。  

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/container-with-most-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


# 1. O(n^2)思路
最简单的思路是枚举所有容积的状况，然后获取一个最大的容积。
eg(最大容积为55):   
index:  0,1,2,3 ,4,5 ,6,7 ,8 ,9  
height: 4,4,2,11,0,11,5,11,13,8  
  
例如从左端点4(height[0])开始，依次遍历右端点8(height[9])、13(height[8])、5(height[7])...  
然后从左端点4(height[1])尅是，依次遍历右端点8(height[9])、13(height[8])、5(height[7])...  
然后从左端点2(height[2])尅是，依次遍历右端点8(height[9])、13(height[8])、5(height[7])...  
....  
这样的操作是O(n^2)的，即左端点完整遍历过一遍(n次)，右端点也完整遍历过一遍(n次)，n为数组的元素数量  
  
这样的操作很容易写，但是由于是O(n^2)的操作，因此会出现overtime。  

# 2. O(n)思路
**首先要明确，容积是高度乘以长度，其中高度是由两侧端点高度较小的那个决定的(类比木桶原理)，其长度是两个端点之间的距离**  
第一种遍历的思路，忽略了容积的决定因素，因此造成了很多不必要的遍历过程。  
例如1,2,3,4,5,6,7,8,9,10这样的数据，  
假设最开始的情况下左端点为1，右端点为10，此时容积是`min(1,10)*(9-0)=9`，  
此时无论右边端点怎么移动，其结果都是两端点距离减小，而高度永远为1(因为1右边的任何数都比它大，右端点永远比左端点这个1要大)，  
即此时对右端点的任何遍历都是多余的。  

又例如:  
eg(最大容积为55):   
index:  0,1,2,3 ,4,5 ,6,7 ,8 ,9  
height: 4,4,2,11,0,11,5,11,13,8  
最开始时，我们左端点为4(height[0])，而此时右端点为大于4的8(height[9])，此时右端点往中间走的任何操作都是多余的，因为：  
a) 若右端点遍历到的某个值比8要大，此时最小值依然是左端点4，而长度作为端点的距离它是一定减小的，此时容积一定减小  
b-1) 若右端点遍历到的某个值比8要小,且这个值比左端点还小，那么此时高度又这个新值决定，此时容器的高度减小，长度也减小，容积一定减小  
b-2) 若右端点遍历到的某个值比8要小,且这个值比左端点要大，那么此时高度依然是由左端点决定，而此时容器的长度是减小的，容积也是减小的  
即，若此时右端点的高度比左端点要大，那么我们此时对右端点的遍历是没有意义的，可以直接跳过右端点遍历，直接令左端点往右遍历  
(可想象成双层for循环，在外层i=0时，内层直接continue到i=1)  
  
依据这个*只遍历高度较小的那一端*的思路，我们在循环中对左右端点进行对比，  
当左端点比右端点小，往右移动左端点，尝试找更大的容积，  
当右端点比左端点小，往左移动右端点，尝试找到更大的容积。  
由于我们并不需要得知最大容积时对应的确切左右端点的值(实际上多添加两个变量记录就可以了)，  
我们直接对左右两根指针进行操作就可以了，当左右两根指针碰上时，即遍历完了，此时左右指针加起来一共遍历了n个次，即实现了O(n)的复杂度。  
  
>
>
>对于数组height，由于是乱序的，因此至少要遍历一遍才能得到最大的容积   
>假设当前最大容积对应的左右端点分别是ai和aj，容积为`min(height[aj],height[ai])*(aj-ai)`,  
>即其高度为两个端点中较低的哪一个，端点为两个端点之间的距离  
>  
>由于小于ai和大于aj的部分我们已经看过了，因此我们此时是往中间，即大于ai或小于aj地方去找一个更大的容积。    
>而由于往中间走，aj-ai必然是减小的，那么如果想要容积增大，至少需要保证`min(height[aj],height[ai])`是变大的    
>  
>假设height[ai]是较小的那个，此时的容积为height[ai]*(aj-ai)：  
>1）如果我们令aj往左移动到next_aj，此时长度(next_aj-ai)减小，  
>1.1) 若height[next_aj]比height[aj]要大，  
>    由于容积是由较小的那个高度决定的，此时高度还是height[ai]*(next_aj-ai),  
>    即此时高度没有变，而长度减小了，总体容积一定是减小的  
>1.2) 若height[next_aj]比height[aj]要小，  
>    此时容积为height[next_aj]*(next_aj-ai),  
>    即高度和长度都减小了，容积也一定是减小的  
>2) 如果我们令ai往右移动到next_ai，此时长度(aj-next_ai)减小，  
>2.1) 若height[next_ai]比height[ai]大，  
>    此时高度是由height[aj]和height[next_ai]中较小的那个决定的，但是一定会比height[ai]要大  
>    此时高度增高，长度减小，是有可能令容积增大的  
>2.2) 若height[next_ai]和height[ai]小，  
>    height[ai]比height[aj]小，而height[next_ai]比height[ai]还小，因此此时最小的一定是height[next_ai]  
>    即此时高度减小，长度也减小，容积是减小的  
>因此，综上看来，只有2.1会出现容积增大的状况，  
>** 对应我们的操作应当是: "比较左右端点，判断哪个端点的高度较小，让这个较小的端点往中间移动，尝试获取一个更大的容积"**  
